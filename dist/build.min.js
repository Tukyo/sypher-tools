const WindowModule={pageFocus:function(){const e="visible"===document.visibilityState;return e?console.log("Page Focused..."):console.log("Page Unfocused..."),e}},TruncationModule={truncate:function(e,t=6,r=4){if("string"!=typeof e)throw new TypeError('TruncationModule.truncate: "string" must be a valid string but received '+typeof e);if(!Number.isInteger(t)||t<0)throw new RangeError(`TruncationModule.truncate: "startLength" must be a non-negative integer but received ${t}`);if(!Number.isInteger(r)||r<0)throw new RangeError(`TruncationModule.truncate: "endLength" must be a non-negative integer but received ${r}`);return e.length<=t+r+3?e:`${e.slice(0,t)}...${e.slice(-r)}`},truncateBalance:function(e,t=2,r=8){if("number"!=typeof e||isNaN(e))throw new TypeError(`TruncationModule.truncateBalance: "balance" must be a valid number but received ${e}`);if(!Number.isInteger(t)||t<0)throw new RangeError(`TruncationModule.truncateBalance: "decimals" must be a non-negative integer but received ${t}`);if(!Number.isInteger(r)||r<=0)throw new RangeError(`TruncationModule.truncateBalance: "maxLength" must be a positive integer but received ${r}`);const o=parseFloat(e);if(o>=1e15)return`${(o/1e15).toFixed(t)}Q`;if(o>=1e12)return`${(o/1e12).toFixed(t)}T`;if(o>=1e9)return`${(o/1e9).toFixed(t)}B`;if(o>=1e6)return`${(o/1e6).toFixed(t)}M`;if(o>=1e3)return`${(o/1e3).toFixed(t)}K`;const[n,i=""]=o.toString().split(".");if(n.length>=r)return n;const a=r-n.length-1,s=i.slice(0,Math.max(a,0));return s?`${n}.${s}`:n}},InterfaceModule={toggleLoader:function(e,t=!0,r,o=""){if(!e||"string"!=typeof r||"string"!=typeof o)throw new TypeError('InterfaceModule.toggleLoader: "element" must be a valid HTMLElement, "loaderHTML" and "newText" must be valid strings.');e.innerHTML=t?r:o},parallax:function(){const e=document.querySelectorAll("[data-speed]");function t(){e.forEach((e=>{const t=parseFloat(e.dataset.speed)||.5,r=window.scrollY*t;e.style.transform=`translateY(${-r}px)`}))}0!==e.length?(window.addEventListener("scroll",(function(){requestAnimationFrame(t)})),t()):console.warn("InterfaceModule.parallax: Parallax enabled, but no elements found with the [data-speed] attribute.")},fade:function(e="20px",t="0.5s"){if("string"!=typeof e||"string"!=typeof t)throw new TypeError('InterfaceModule.fade: "distance" and "length" must be valid strings.');const r=document.querySelectorAll("[data-fade]");if(0===r.length)return void console.warn("InterfaceModule.fade: Fade enabled, but no elements found with the [data-fade] attribute.");r.forEach((r=>{r.style.opacity=0,r.style.transform=`translateY(${e})`,r.style.transition=`opacity ${t} ease-out, transform ${t} ease-out`}));const o=new IntersectionObserver((t=>{t.forEach((t=>{const r=t.target;t.isIntersecting&&t.intersectionRatio>.1?(r.style.opacity=1,r.style.transform="translateY(0)"):(r.style.opacity=0,r.style.transform=`translateY(${e})`)}))}),{threshold:.1});r.forEach((e=>o.observe(e)))}},CryptoInterfaceModule={createConnectButton:function(e=document.body,t=()=>sypher.connect("ethereum"),r={text:"Connect Wallet",modal:!1}){if(!e||"object"!=typeof e)throw new TypeError('CryptoInterfaceModule.createConnectButton: "element" must be a valid HTMLElement.');if("function"!=typeof t)throw new TypeError('CryptoInterfaceModule.createConnectButton: "onClick" must be a valid function.');if("object"!=typeof r||null===r)throw new TypeError('CryptoInterfaceModule.createConnectButton: "params" must be a valid object.');const{text:o="Connect Wallet",modal:n=!1}=r;if("string"!=typeof o)throw new TypeError('CryptoInterfaceModule.createConnectButton: "params.text" must be a valid string.');const i=document.createElement("button");return i.classList.add("connect-button"),i.textContent=o,i.onclick=t,e.appendChild(i),i}},CHAINLINK_ABI=["function latestRoundData() view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)"],ERC20_ABI=["function allowance(address owner, address spender) view returns (uint256)","function approve(address spender, uint256 amount) returns (bool)","function balanceOf(address account) view returns (uint256)","function decimals() view returns (uint8)","function name() view returns (string)","function symbol() view returns (string)","function totalSupply() view returns (uint256)","function transfer(address to, uint256 amount) returns (bool)"],UNISWAP_V2_POOL_ABI=["function getReserves() view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast)","function token0() view returns (address)","function token1() view returns (address)","function totalSupply() view returns (uint256)","function balanceOf(address owner) view returns (uint256)","function allowance(address owner, address spender) view returns (uint256)","function approve(address spender, uint256 value) returns (bool)","function transfer(address to, uint256 value) returns (bool)","function transferFrom(address from, address to, uint256 value) returns (bool)"],UNISWAP_V3_POOL_ABI=["function slot0() view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked)","function token0() view returns (address)","function token1() view returns (address)","function fee() view returns (uint24)","function decimals() view returns (uint8)","function liquidity() view returns (uint128)"],CHAINS={ethereum:{params:[{chainId:"0x1",chainName:"Ethereum",nativeCurrency:{name:"Ethereum",symbol:"ETH",decimals:18},rpcUrls:["https://eth.llamarpc.com"],blockExplorerUrls:["https://etherscan.io"]}],priceFeeds:{eth:"0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419"},pairAddresses:{eth:"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"}},arbitrum:{params:[{chainId:"0xa4b1",chainName:"Arbitrum",nativeCurrency:{name:"Arbitrum",symbol:"ETH",decimals:18},rpcUrls:["https://arbitrum.llamarpc.com"],blockExplorerUrls:["https://arbiscan.io"]}],priceFeeds:{eth:"0x639Fe6ab55C921f74e7fac1ee960C0B6293ba612",arb:"0xb2A824043730FE05F3DA2efaFa1CBbe83fa548D6"},pairAddresses:{eth:"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",arb:"0xB50721BCf8d664c30412Cfbc6cf7a15145234ad1"}},optimism:{params:[{chainId:"0xa",chainName:"Optimism",nativeCurrency:{name:"Optimism",symbol:"ETH",decimals:18},rpcUrls:["https://optimism.llamarpc.com"],blockExplorerUrls:["https://optimistic.etherscan.io"]}],priceFeeds:{eth:"0xb7B9A39CC63f856b90B364911CC324dC46aC1770",op:"0x0D276FC14719f9292D5C1eA2198673d1f4269246"},pairAddresses:{eth:"0x4200000000000000000000000000000000000006",op:"0x4200000000000000000000000000000000000042"}},base:{params:[{chainId:"0x2105",chainName:"Base",nativeCurrency:{name:"Base",symbol:"ETH",decimals:18},rpcUrls:["https://mainnet.base.org"],blockExplorerUrls:["https://basescan.org"]}],priceFeeds:{eth:"0x71041dddad3595F9CEd3DcCFBe3D1F4b0a16Bb70"},pairAddresses:{eth:"0x4200000000000000000000000000000000000006"}},polygon:{params:[{chainId:"0x89",chainName:"Polygon",nativeCurrency:{name:"Polygon",symbol:"POL",decimals:18},rpcUrls:["https://polygon.llamarpc.com"],blockExplorerUrls:["https://polygonscan.com"]}],priceFeeds:{eth:"0xF9680D99D6C9589e2a93a78A04A279e509205945",matic:"0xAB594600376Ec9fD91F8e885dADF0CE036862dE0"},pairAddresses:{eth:"0x11CD37bb86F65419713f30673A480EA33c826872",matic:"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270"}},avalanche:{params:[{chainID:"0xa86a",chainName:"Avalanche",nativeCurrency:{name:"Avalanche",symbol:"AVAX",decimals:18},rpcUrls:["https://avalanche.drpc.org"],blockExplorerUrls:["https://snowtrace.io"]}],priceFeeds:{eth:"0x976B3D034E162d8bD72D6b9C989d545b839003b0",avax:"0x0A77230d17318075983913bC2145DB16C7366156"},pairAddresses:{eth:"",avax:""}},fantom:{params:[{chainId:"0xfa",chainName:"Fantom",nativeCurrency:{name:"Fantom",symbol:"FTM",decimals:18},rpcUrls:["https://rpc.ftm.tools"],blockExplorerUrls:["https://ftmscan.com"]}],priceFeeds:{eth:"0x11DdD3d147E5b83D01cee7070027092397d63658",ftm:"0xf4766552D15AE4d256Ad41B6cf2933482B0680dc"},pairAddresses:{eth:"",ftm:""}}},CryptoModule={initCrypto:async function(e,t,r,o,n="eth"){if("string"!=typeof e||!e.trim())throw new TypeError(`CryptoModule.initCrypto: "chain" must be a non-empty string but received ${typeof e} with value "${e}"`);if("string"!=typeof t||!/^0x[a-fA-F0-9]{40}$/.test(t))throw new TypeError(`CryptoModule.initCrypto: "contractAddress" must be a valid Ethereum address but received "${t}"`);if("string"!=typeof r||!/^0x[a-fA-F0-9]{40}$/.test(r))throw new TypeError(`CryptoModule.initCrypto: "poolAddress" must be a valid Ethereum address but received "${r}"`);if("string"!=typeof o||!["V2","V3"].includes(o))throw new RangeError(`CryptoModule.initCrypto: "version" must be "V2" or "V3" but received "${o}"`);if("string"!=typeof n||!n.trim())throw new TypeError(`CryptoModule.initCrypto: "pair" must be a non-empty string but received "${n}"`);const i=CHAINS[e];if(!i)throw new Error(`CryptoModule.getPriceFeed: Chain "${e}" is not supported.`);const a=i.params[0]?.chainId;if(!a)throw new Error(`CryptoModule.getPriceFeed: Missing chainId for chain "${e}".`);try{if(!await this.connect(e))return null;console.log("Getting details for:",{chain:e,contractAddress:t,poolAddress:r,version:o,pair:n});const{balance:i,decimals:a,name:s,symbol:c,totalSupply:l}=await this.getTokenDetails(e,t);let u=null;"V2"===o&&(u=await this.getPriceV2(e,r,n)),"V3"===o&&(u=await this.getPriceV3(e,t,r,n));const d=this.getUserValue(i,u);return this.clean({contractAddress:t,poolAddress:r,balance:i,decimals:a,name:s,symbol:c,totalSupply:l,tokenPrice:u,userValue:d})}catch(e){return console.error(`CryptoModule.initCrypto: An error occurred during initialization: ${e.message}`),null}},connect:async function(e){if("string"!=typeof e||!e.trim())throw new TypeError(`CryptoModule.connect: "chain" must be a non-empty string but received ${typeof e} with value "${e}"`);if(!window.ethereum)throw new Error("CryptoModule.connect: No Ethereum provider found....");try{const t=await window.ethereum.request({method:"eth_requestAccounts"});if(!Array.isArray(t)||0===t.length)throw new Error("CryptoModule.connect: No accounts returned by the Ethereum provider.");this.connect.logged||(console.log("Accounts:",t),this.connect.logged=!0),await this.switchChain(e);const r=t[0];return r||(console.warn("CryptoModule.connect: Wallet not connected."),null)}catch(e){throw console.error(`CryptoModule.connect: Connection error occurred: ${e.message}`),new Error(`CryptoModule.connect: Failed to connect to the Ethereum provider. Details: ${e.message}`)}},switchChain:async function(e){if("string"!=typeof e||!e.trim())throw new TypeError(`CryptoModule.switchChain: "chain" must be a non-empty string but received ${typeof e} with value "${e}"`);if(!window.ethereum)throw new Error("CryptoModule.switchChain: No Ethereum provider found....");const t=CHAINS[e];if(!t||!t.params)throw new Error(`CryptoModule.switchChain: Chain "${e}" is not supported.`);try{if(!await this.connect(e))return null;const r=t.params[0].chainId;if(await window.ethereum.request({method:"eth_chainId"})===r)return;console.log(`Switching to ${e} chain...`),await window.ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:r}]})}catch(r){if(console.warn(`CryptoModule.switchChain: Attempting to add chain: ${e}`),4902!==r.code)throw new Error(`CryptoModule.switchChain: Failed to switch to chain "${e}". Details: ${r.message}`);try{await window.ethereum.request({method:"wallet_addEthereumChain",params:t.params})}catch(t){throw new Error(`CryptoModule.switchChain: Unable to switch or add chain "${e}". Details: ${t.message}`)}}},getPriceFeed:async function(e,t="eth"){if(!window.ethereum)throw new Error("CryptoModule.getPriceFeed: No Ethereum provider found....");if("string"!=typeof e||!e.trim())throw new TypeError(`CryptoModule.getPriceFeed: "chain" must be a non-empty string but received ${typeof e} with value "${e}"`);if("string"!=typeof t||!t.trim())throw new TypeError(`CryptoModule.getPriceFeed: "pair" must be a non-empty string but received "${t}"`);const r=CHAINS[e];if(!r)throw new Error(`CryptoModule.getPriceFeed: Chain "${e}" is not supported.`);const o=r.params[0]?.chainId;if(!o)throw new Error(`CryptoModule.getPriceFeed: Missing chainId for chain "${e}".`);try{if(!await this.connect(e))return null;const r=CHAINS[e].priceFeeds[t];if(!r)throw new Error(`Chain ${e} is not supported`);const o=new ethers.providers.Web3Provider(window.ethereum).getSigner(),n=new ethers.Contract(r,CHAINLINK_ABI,o),i=await n.latestRoundData(),a=ethers.utils.formatUnits(i.answer,8);return console.log(`ETH Price on ${e}: $${a}`),a}catch(e){throw new Error(`CryptoModule.getPriceFeed: Error fetching price feed: ${e.message}`)}},getTokenDetails:async function(e,t){if("string"!=typeof e||!e.trim())throw new TypeError(`CryptoModule.getTokenDetails: "chain" must be a non-empty string but received ${typeof e} with value "${e}"`);if("string"!=typeof t||!/^0x[a-fA-F0-9]{40}$/.test(t))throw new TypeError(`CryptoModule.getTokenDetails: "contractAddress" must be a valid Ethereum address but received "${t}"`);if(!window.ethereum)throw new Error("CryptoModule.getTokenDetails: No Ethereum provider found....");try{if(!await this.connect(e))return null;const r=new ethers.providers.Web3Provider(window.ethereum).getSigner(),o=await r.getAddress(),n=new ethers.Contract(t,ERC20_ABI,r),i=await n.balanceOf(o),a=await n.decimals(),s=await n.name(),c=await n.symbol(),l=await n.totalSupply();return console.log("Token Details:",{balance:i,decimals:a,name:s,symbol:c,totalSupply:l}),{balance:i,decimals:a,name:s,symbol:c,totalSupply:l}}catch(e){throw new Error(`CryptoModule.getTokenDetails: Error fetching token details: ${e.message}`)}},getPriceV2:async function(e,t,r){if("string"!=typeof e||!e.trim())throw new TypeError(`CryptoModule.getPriceV2: "chain" must be a non-empty string but received ${typeof e} with value "${e}"`);if("string"!=typeof t||!/^0x[a-fA-F0-9]{40}$/.test(t))throw new TypeError(`CryptoModule.getPriceV2: "poolAddress" must be a valid Ethereum address but received "${t}"`);if("string"!=typeof r||!r.trim())throw new TypeError(`CryptoModule.getPriceV2: "pair" must be a non-empty string but received "${r}"`);if(!window.ethereum)throw new Error("CryptoModule.getPriceV2: No Ethereum provider found....");const o=CHAINS[e];if(!o)throw new Error(`CryptoModule.getPriceFeed: Chain "${e}" is not supported.`);const n=o.params[0]?.chainId;if(!n)throw new Error(`CryptoModule.getPriceFeed: Missing chainId for chain "${e}".`);try{if(!await this.connect(e))return null;const o=await this.getPriceFeed(e,r);if(!o)return null;const n=new ethers.providers.Web3Provider(window.ethereum).getSigner(),i=new ethers.Contract(t,UNISWAP_V2_POOL_ABI,n),a=await i.token0(),s=await i.token1(),c=await i.getReserves(),l=c._reserve0,u=c._reserve1,d=new ethers.Contract(a,ERC20_ABI,n),p=new ethers.Contract(s,ERC20_ABI,n),h=await d.decimals(),m=await p.decimals();console.log("Reserve 0:",l),console.log("Reserve 1:",u),console.log("Token 0:",a),console.log("Token 1:",s),console.log("Decimals 0:",h),console.log("Decimals 1:",m);const w=ethers.BigNumber.from(l),f=ethers.BigNumber.from(u),y=parseFloat(ethers.utils.formatUnits(w,h)),g=parseFloat(ethers.utils.formatUnits(f,m)),b=CHAINS[e].pairAddresses[r];console.log("Pair Address:",b);let C=null;if(s.toLowerCase()===b.toLowerCase())C=g/y;else{if(a.toLowerCase()!==b.toLowerCase())throw new Error(`CryptoModule.getPriceV2: Neither token is ${r}`);C=y/g}const v=C*o;return console.log(`V2 Price for token in pool ${t}: $${v}`),v}catch(e){throw new Error(`CryptoModule.getPriceV2: Error calculating V2 token price: ${e.message}`)}},getPriceV3:async function(e,t,r,o){if("string"!=typeof e||!e.trim())throw new TypeError(`CryptoModule.getPriceV3: "chain" must be a non-empty string but received ${typeof e} with value "${e}"`);if("string"!=typeof t||!/^0x[a-fA-F0-9]{40}$/.test(t))throw new TypeError(`CryptoModule.getPriceV3: "contractAddress" must be a valid Ethereum address but received "${t}"`);if("string"!=typeof r||!/^0x[a-fA-F0-9]{40}$/.test(r))throw new TypeError(`CryptoModule.getPriceV3: "poolAddress" must be a valid Ethereum address but received "${r}"`);if("string"!=typeof o||!o.trim())throw new TypeError(`CryptoModule.getPriceV3: "pair" must be a non-empty string but received "${o}"`);if(!window.ethereum)throw new Error("CryptoModule.getPriceV3: No Ethereum provider found....");const n=CHAINS[e];if(!n)throw new Error(`CryptoModule.getPriceFeed: Chain "${e}" is not supported.`);const i=n.params[0]?.chainId;if(!i)throw new Error(`CryptoModule.getPriceFeed: Missing chainId for chain "${e}".`);try{if(!await this.connect(e))return null;const{sqrtPriceX96:n,token0:i,token1:a,decimals0:s,decimals1:c}=await this.getPoolV3(e,t,r),l=CHAINS[e].pairAddresses[o];console.log("Pair Address:",l);const u=ethers.BigNumber.from(n),d=ethers.BigNumber.from("79228162514264337593543950336"),p=u.mul(u).mul(ethers.BigNumber.from(10).pow(s)),h=d.mul(d).mul(ethers.BigNumber.from(10).pow(c)),m=p.div(h),w=p.mod(h),f=8,y=ethers.BigNumber.from(10).pow(f),g=w.mul(y).div(h),b=parseFloat(m.toString())+parseFloat(g.toString())/Math.pow(10,f);let C;if(a.toLowerCase()===l.toLowerCase())C=b;else{if(i.toLowerCase()!==l.toLowerCase())throw new Error(`CryptoModule.getPriceV3: Neither token is ${o}`);C=1/b}const v=await this.getPriceFeed(e,o);if(!v)return null;const E=C*parseFloat(v);return console.log(`V3 Price for token in pool ${r}: $${E}`),E}catch(e){throw new Error(`CryptoModule.getPriceV3: Error calculating V3 token price: ${e.message}`)}},getPoolV3:async function(e,t,r){if("string"!=typeof e||!e.trim())throw new TypeError(`CryptoModule.getPoolV3: "chain" must be a non-empty string but received ${typeof e} with value "${e}"`);if("string"!=typeof t||!/^0x[a-fA-F0-9]{40}$/.test(t))throw new TypeError(`CryptoModule.getPoolV3: "contractAddress" must be a valid Ethereum address but received "${t}"`);if("string"!=typeof r||!/^0x[a-fA-F0-9]{40}$/.test(r))throw new TypeError(`CryptoModule.getPoolV3: "poolAddress" must be a valid Ethereum address but received "${r}"`);if(!window.ethereum)throw new Error("CryptoModule.getPoolV3: No Ethereum provider found....");try{if(!await this.connect(e))return null;const t=new ethers.providers.Web3Provider(window.ethereum).getSigner(),o=new ethers.Contract(r,UNISWAP_V3_POOL_ABI,t),n=(await o.slot0()).sqrtPriceX96;console.log("Sqrt Price X96:",n);const i=await o.token0(),a=await o.token1();console.log("Token 0:",i),console.log("Token 1:",a);const s=new ethers.Contract(i,ERC20_ABI,t),c=new ethers.Contract(a,ERC20_ABI,t),l=await s.decimals(),u=await c.decimals();console.log("Decimals 0:",l),console.log("Decimals 1:",u);const d=await o.liquidity();return console.log("Liquidity:",d),{sqrtPriceX96:n,token0:i,token1:a,decimals0:l,decimals1:u,liquidity:d}}catch(e){throw new Error(`CryptoModule.getPoolV3: Error fetching V3 pool details: ${e.message}`)}},getUserValue:function(e,t){try{const r=parseFloat(e)*parseFloat(t);return console.log(`User Value: ${r}`),r}catch(e){return console.error("Error calculating user value:",e),null}},clean:function(e){if(!e||"object"!=typeof e)throw new TypeError(`CryptoModule.clean: "tokenDetails" must be an object but received ${typeof e} with value "${e}"`);const{contractAddress:t,poolAddress:r,balance:o,decimals:n,name:i,symbol:a,totalSupply:s,tokenPrice:c,userValue:l}=e,u={contractAddress:t,poolAddress:r,balance:parseFloat(ethers.utils.formatUnits(o,n)),decimals:n,name:i,symbol:a,totalSupply:parseFloat(ethers.utils.formatUnits(s,n)),tokenPrice:parseFloat(c),userValue:(parseFloat(l)/Math.pow(10,n)).toFixed(n)};return console.log("Token Details:",u),u}};!function(e){const t={};Object.assign(t,WindowModule),Object.assign(t,TruncationModule),Object.assign(t,InterfaceModule),Object.assign(t,CryptoModule),Object.assign(t,CryptoInterfaceModule),e.sypher=t,console.log("Sypher Modules Initialized!")}(window); 